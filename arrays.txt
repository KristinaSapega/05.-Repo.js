//1
/* Дан массив: 
[1, 5, 4, 10, 0, 3]
Необходимо создать цикл, который будет выводить элементы массива 
до тех пор, пока не встретит значение 10.
После вывода значения 10 в консоль цикл должен прекратить свою работу.*/

const numbs = [1, 5, 4, 10, 0, 3];
for (let i = 0; i < numbs.length; i++) {
    if (numbs[i] === 10) {
    console.log(numbs[i]);
    break;
}
  console.log(numbs[i]);
}


//2
/* Дан массив: 
[1, 5, 4, 10, 0, 3].
Найдите позицию числа 4 в этом массиве.*/

const numbs2 = [1, 5, 4, 10, 0, 3];
const index = numbs2.indexOf(4);
console.log(index);

вар.2
const numbs2 = [1, 5, 4, 10, 0, 3];
let index = -1;
numbs2.forEach((el, i) => {
  if (el === 4) { 
    index = i; 
  }
});
console.log(index); 


//3
/*Дан массив чисел: [1, 3, 5, 10, 20].
С помощью метода join выведите элементы массива
через пробел (пустую строку ' ').*/

let numbs3 = [1, 3, 5, 10, 20];
numbs3 = numbs3.join(' ');
console.log(numbs3);

//4
/*С помощью вложенных циклов создайте многомерный массив вида: 
[[1, 1, 1], [1, 1, 1], [1, 1, 1]].*/

const arr = [];
for (let i = 0; i < 3; i++) {
    arr [i] = [];
    for (let j = 0; j < 3; j++) {
        arr[i][j] = 1;
    }
}
console.log(arr);

В многомерном массиве каждый элемент имеет два индекса - 
первый для указания строки, в которой находится элемент, 
а второй для указания столбца, в котором он находится.
В данном коде i и j - это переменные, которые используются для обращения 
к элементам массива. Внешний цикл for проходит по строкам массива 
и использует переменную i в качестве индекса строки, 
а вложенный цикл проходит по столбцам массива и использует переменную j 
в качестве индекса столбца.
Таким образом, i и j - это просто обычные переменные, используемые 
для итерации по многомерному массиву.

i < 3 используется как условие для внешнего цикла for. 
Это означает, что цикл будет выполняться до тех пор, пока значение переменной i 
меньше 3. Поскольку многомерный массив, который мы создаем, имеет 3 строки, 
то условие i < 3 гарантирует, что мы пройдем по каждой строке массива. 
Если бы мы указали i < 2 или i < 4, то мы либо не обошли бы все строки массива,
либо пройдем по строке, которой на самом деле нет в нашем массиве.
Конечно, условие i < 3 может быть заменено на другое, 
если требуется создать многомерный массив другой размерности. 
Например, если мы хотим создать многомерный массив с 4 строками, 
мы можем изменить условие на i < 4.

//5
/* Дан массив: [1, 1, 1].
Добавьте в конец массива значения 2, 2, 2.*/

let arr2 = [1, 1, 1];
arr2.push (2, 2, 2);
console.log(arr2);

//6
/*Дан массив: [9, 8, 7, 'a', 6, 5].
С помощью метода sort отсортируйте массив и удалите букву 'a' из данного массива.
В результате работы программы вывести массив, состоящий из цифр.*/

let arr3 = [9, 8, 7, 'a', 6, 5];
arr3.sort ();
arr3.pop ();
console.log(arr3);

//7
/*Дан массив: [9, 8, 7, 6, 5].
Пользователь с клавиатуры вводит число от 1 до 10 (использовать prompt()). 
Необходимо проверить, содержится ли введенное пользователем число в 
данном массиве.*/

const numbers = [9, 8, 7, 6, 5];
const input = Number(prompt('Введите число от 1 до 10:'));
if (numbers.includes (input)) {
  console.log (`Число ${input} есть в массиве`);            
} else {
  console.log (`Число ${input} отсутсвует в массиве`);
}


//8
/*Дана строка: 'abcdef'.
Необходимо, чтобы программа вывела в консоль 'fedcba'.*/

let arr4 = 'abcdef';
let result = arr4.split('').reverse().join('');
console.log(result);

//9
/* Дан массив: 
[[1, 2, 3,],[4, 5, 6]].
Выведите в консоль массив вида: 
[1, 2, 3, 4, 5, 6]*/

let arr5 = [[1, 2, 3,],[4, 5, 6]];
let result2 = arr5[0].concat(arr5[1]);
console.log(result2);

Mетод concat() не изменяет исходный массив, а возвращает новый массив,
который является объединением (конкатенацией) исходного массива 
и переданных аргументов.
Cначала обращаемся к элементам массива arr5 по индексам [0] и [1], 
чтобы получить два массива [1, 2, 3] и [4, 5, 6]. 
Затем мы вызываем метод concat() для первого массива и 
передаем в качестве аргумента второй массив. 
Результатом будет новый массив [1, 2, 3, 4, 5, 6], который мы выводим в консоль.

//10
/* Создайте массив с произвольными числами (диапазон от 1 до 10). 
Переберите его с помощью цикла for и в каждой итерации выведите в консоль сумму
текущего и следующего элементов массива.
Следующий элемент массива можно получить с помощью индекса: 
i + 1. Обратите внимание, что у последнего элемента нет следующего.*/

let a = [6, 8, 4, 3, 7, 1, 5, 2, 9, 10];
for (let i = 0; i < a.length; i++) {
    console.log(a[i] + a[i + 1]);
}

используя выражение i < a.length - 1, мы гарантируем, что переменная i 
не превысит индекс последнего элемента массива a. Это необходимо, 
чтобы мы могли получить доступ к следующему элементу массива, используя 
выражение a[i+1].
Если мы используем выражение i < a.length в цикле for, 
то на последней итерации мы получим ошибку, когда попытаемся получить 
доступ к несуществующему элементу массива a[i+1], так как индекс i+1 
будет выходить за границы массива.
Поэтому мы используем i < a.length - 1, чтобы гарантировать, 
что индекс i+1 будет всегда указывать на существующий элемент массива, 
кроме последней итерации, где мы обрабатываем последний элемент 
массива отдельно.
Выражение (a[i] + a[i + 1]) вычисляет сумму текущего элемента массива a[i]
 и следующего элемента массива a[i + 1]

//11
/*Создайте функцию, которая принимает на вход массив целых чисел, 
а возвращает массив квадратов этих чисел. для решения задачи используйте 
map()*/

const b = [4, 5, 7, 9, 2, 0];
let squared = b.map(item => (item ** 2));
console.log(squared);

//12
/* Создайте функцию, которая принимает на вход массив строк, 
а возвращает массив длинны слов.*/

const c = ['apple', 'capcake', 'car', 'travel'];
const getLengthWords = arr => arr.map(word => word.length);
console.log(getLengthWords(c)); 

вар 2
function getLengthWords(arr) {
    return arr.map(word => word.length);
  }
const c = ['apple', 'capcake', 'car', 'travel'];
const wordLengths = getLengthWords(c);
console.log(wordLengths);

В данном случае, мы хотим вернуть массив длин слов из массива строк c. 
Для этого мы используем метод map(), который применяет анонимную функцию к
каждому элементу c. Эта функция берет каждое слово в массиве и возвращает его
длину, используя свойство length. В данном случае word - это название 
параметра функции, которое мы можем использовать внутри функции для ссылки 
на текущий элемент массива.
Поэтому запись word => word.length означает, что мы берем текущий элемент 
массива word и возвращаем его свойство length, которое является длиной этого слова.

//13
/*