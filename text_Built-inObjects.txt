Примитивы — это данные, которые не являются объектом и не имеют методов.
В JavaScript семь простых типов данных: string, number, boolean, symbol, null, undefined и bigint.
Объект — это самостоятельная единица, имеющая свойства и определенный тип. 

Объекты в JS могут хранить множество значений как свойства.
Объекты в программировании можно сравнить с объектами из реального мира. 
Например, у объекта «телефон» есть свойства: вес, форма, модель, цвет, 
и функции: звонить, фотографировать, принимать сообщения.

Объекты объявляются при помощи фигурных скобок {}, например:{name: "Рома", age: 30}.
Особенность примитивных типов данных заключается в том, что они неизменяемы (иммутабельны) 
и передаются по значению. В отличие от объектов, которые передаются по ссылке.

В JS есть механизм, который позволяет обращаться к примитивам с помощью методов. 
Этот инструмент — специальные объекты-обертки, которые предоставляют нужную функциональность, 
а после удаляются.
Объекты-обертки — это объекты, которые позволяют вызывать у примитивов методы.

let str = 'Строка'; // объявили переменную и присвоили ей значение
console.log(str.toUpperCase()); // СТРОКА
==
let str = 'Строка'; // пока здесь всё понятно, ничего нового
// далее среда выполнения видит примитив, который вызывает метод
// в этот момент переменная str оборачивается в объект-обертку
// и фактически происходит следующее
console.log(new String(str).toUpperCase());

// оставить после запятой 2 знака
123.098876.toFixed(2); // '123.10'

Каждый примитив имеет свой собственный объект-обертку:
Для строк string это String; 
Для числовых значений number — Number;
Для булевых переменных boolean — Boolean;
Для примитивного типа symbol существует объект-обертка Symbol;
Для числового типа bigint — объект-обертка BigInt.

Обратите внимание: примитивы пишутся с маленькой буквы, а объекты-обертки — с большой.

Все объекты-обертки являются встроенными объектами.

Встроенные объекты языка — это объекты, доступные в любом месте скрипта и в любой ситуации.

2. Методы String
Изменение регистра
Методы toLowerCase() и toUpperCase()
меняют регистр символов, приводят к нижнему и верхнему соответственно. 
Прежде чем рассмотреть первый пример, давайте разберемся, для чего нам может понадобиться 
приводить строку к нижнему или верхнему регистру.

f.e.
const answerUser = prompt('Без рук, а рисует. Без зубов, а кусает'); // сохраняем
// ответ пользователя в переменную answerUser
const answer = 'мороз'; // храним правильный ответ в переменной answer

if (answerUser.toLowerCase() === answer.toLowerCase()) { // проверяем, совпадает ли строка, полученная от пользователя, с правильным ответом
// и теперь нам не важно, в каком регистре какие буквы ввел пользователь, мы все приводим к нижнему регистру
	alert('Это правильный ответ!'); // это сообщение, если совпала
} else {
	alert('Не угадал, правильный ответ: ${answer}'); // а это, если не совпала
}

Поиск подстроки
Существует несколько способов поиска подстроки.
str.indexOf
Первый метод — str.indexOf(substr, pos).
Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, 
на которой располагается совпадение, либо -1 при отсутствии совпадений.

const str = 'Поезд едет далеко'; // строка, в которой будем осуществлять поиск
str.indexOf('едет'); // 6, 'едет' — это подстрока, которую мы ищем, метод вернет
// 6, т. к. «едет» есть в искомой строке str, и совпадение начинается с 6-го индекса
// позиции в строках начинаются с 0
str.indexOf('едит'); // -1, т. к. «едит» — нет полного совпадения подстроки

str.includes
Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока 
substr, либо false, если нет.
Этот метод подойдет в работе, когда нам нужно проверить, есть ли совпадение значения, н
о позиция при этом не важна. 

Код ниже лежит в основе реализации элемента «поиск» во многих веб-приложениях.
const products = ['Хлеб Бородинский', 'Молоко Молочник', 'Коровка Молоко', 'Груша Конференция'];
const search = 'молоко';
products.forEach((product) => {
	// проходимся по массиву products и проверяем каждый элемент на наличие 
	// подстроки 'молоко', не забыв привести элемент и искомую подстроку
	// к одному регистру
	if (product.toLowerCase().includes(search.toLowerCase())) {
		console.log(product);
	}
}); // в результате будет выведено 'Молоко Молочник', 'Коровка Молоко'

str.startsWith и str.endsWidth
str.startsWith и str.endsWith — это методы, которые проверяют, 
какой подстрокой начинается и заканчивается строка соответственно.

Давайте немного изменим условие задачи выше. Теперь нам важно, чтобы наименование товара не просто содержало 
слово «молоко», но и начиналось с него. Для этого нам отлично подойдет метод startsWith:
const products = ['Хлеб Бородинский', 'Молоко Молочник', 'Коровка Молоко', 'Груша Конференция'];
const search = 'молоко';

products.forEach((product) => {
	// проходимся по массиву products и проверяем каждый элемент на наличие 
	// подстроки 'молоко' в начале названия, не забыв привести элемент и
	// искомую подстроку к одному регистру
	if (product.toLowerCase().startsWith(search.toLowerCase())) {
		console.log(product);
	}
}); // в результате будет выведено 'Молоко Молочник'

!!! Метод split 
Он практически всегда используется в связке с методом массива join.
Например, когда нужно выяснить, является ли слово палиндромом.

function palindrom(word) {
	return word.toUpperCase() === word.toUpperCase().split('').reverse().join('');
}
palindrom('мак'); // false
palindrom('заказ'); // true


Объект Date позволяет работать с датами и временем в JavaScript.
Существуют различные способы создания объекта Date.
Первый способ заключается в использовании пустого конструктора без параметров:

let currentDate = new Date();
console.log(currentDate);
В этом случае объект будет указывать на текущую дату компьютера

Второй способ заключается в передаче в конструктор Date количества миллисекунд, 
которые прошли с начала эпохи Unix, то есть с 1 января 1970 года 00:00:00 GMT.

let myDate = new Date(1674220924819);
console.log(myDate); 
//Fri Jan 20 2023 16:22:04 GMT+03:00 (Москва, стандартное время)

Третий способ состоит в передаче в конструктор Date дня, месяца и года:

let myDate = new Date("27 March 2021");
// или так
// let myDate = new Date("3/27/2021");
console.log.write(myDate); 
// Sat Mar 27 2021 00:00:00 GMT+03:00 (Москва, стандартное время)
Если мы используем полное название месяца, то оно пишется по-английски, 
если используем сокращенный вариант, тогда используется формат «месяц/день/год». 
Если попытаться передать некорректное значение, например:

let myDate = new Date("27 Март 2021");
То получим значение Invalid Date.

Четвертый способ состоит в передаче в конструктор Date всех параметров даты и времени:

let myDate = new Date(2025, 5, 25, 12, 30, 20, 10); 
// Wed Jun 25 2025 12:30:20 GMT+03:00 (Москва, стандартное время)
В данном случае используются по порядку следующие параметры: 
new Date(год, месяц, число, час, минуты, секунды, миллисекунды). 
При этом надо учитывать, что отсчет месяцев начинается с нуля, то есть январь — 0, а декабрь — 11.

Получение даты и времени
Для получения различных компонентов даты применяется ряд методов:

getDate(): возвращает день месяца.

getDay(): возвращает день недели. Отсчет начинается с 0 — воскресенье, и последний день — 6 — суббота.

getMonth(): возвращает номер месяца. Отсчет начинается с нуля, то есть месяц с номером 0 — январь.

getFullYear(): возвращает год.

toDateString(): возвращает полную дату в виде строки.

getHours(): возвращает час (от 0 до 23).

getMinutes(): возвращает минуты (от 0 до 59).

getSeconds(): возвращает секунды (от 0 до 59).

getMilliseconds(): возвращает миллисекунды (от 0 до 999).

toTimeString(): возвращает полное время в виде строки.


Объект RegExp.
Чтобы решить проблему выше, мы можем использовать шаблон: /^[а-яА-Я]*$/
С помощью него мы можем иметь строку любой длины, содержащую только кириллические символы.

Регулярное выражение состоит из шаблона, или паттерна, и необязательных флагов.

Что такое шаблон, мы разобрали выше. Флаги рассмотрим чуть позже; на данный момент стоит знать, что их в JS 6: 
i, g, m, s, u, y.

Как же создавать регулярные выражения в JS?

Существуют два синтаксиса для создания регулярного выражения.

let regexp = new RegExp('^[а-яА-Я]*$'); // без флагов
let regexpFlag = new RegExp('^[а-яА-Я]*$', 'gmi'); // с флагами gmi
let regexp = /^[а-яА-Я]*$/; // без флагов
let regexpFlag = /^[а-яА-Я]*$/gmi; // с флагами gmi
Слеши 
/.../
 говорят JavaScript о том, что это регулярное выражение. Они играют здесь ту же роль, что и кавычки для обозначения строк.

Основная разница между этими двумя способами создания заключается в том, что слеши 
/.../
 не допускают никаких вставок переменных (наподобие возможных в строках через 
${...}
).

Слеши используются, когда мы точно знаем, каким будет регулярное выражение, и это большинство ситуаций.

regexp.test(str) ищет совпадение и возвращает true/false в зависимости от того, находит ли он его.

regexp.exec(str) ищет совпадение с regexp в строке str.

let regexp = /^[а-яА-Я]*$/; // что означает эта запись, мы разберем чуть ниже
let name = prompt('Введите ваше имя. Используйте только кириллические символы');

if (regexp.test(name)) {
	alert('Ваше имя сохранено');
} else {
	alert('Введены некорректные символы');
}

что означают разные символы в RegExp, и начнем с нашего примера 
/^[а-яА-Я]*$/:

/…/ — прямой слеш в начале и в конце говорят JS, что это объект RegExp;

^ — означает, что начало строки должно начинаться с символа, идущего после^.

[] — набор символов, перечисление (символ строки должен совпадать хотя бы с одним из вариантов)

а-яА-Я — диапазон букв;

а-я — это все строчные буквы кириллицы;

А-Я — все заглавные буквы кириллицы;

A-Z — все заглавные буквы латиницы.

$ - означает, что строка должна заканчиваться символом, стоящим перед $

/^[а-яА-Я]*$/ — здесь мы сообщаем JS, что первый и последний символы должны быть 
а-яА-Я, но т. к. у нас стоит *, то следующий символ, идущий за первым, должен соответствовать шаблону, 
следующий — второму, и т. д. При этом мы говорим, что и последний символ должен соответствовать шаблону. 
Также благодаря * строка может быть пустой. Это нам необходимо, когда поле является необязательным, 
но если пользователь его заполняет, то необходимо следовать определенным правилам.

Но если мы хотим, чтобы регулярное выражение выполняло проверку на то, что есть хотя бы один символ, 
то нам стоит воспользоваться +.
+ — один или более предшествующий символ, т. е. символ, находящийся перед + (квантификатор).
let regexp = /^[а-яА-Я]+$/;
regexp.test('АбвAbc'); // false, т. к. встречаются некириллические символы

несколько часто встречающихся символов в регулярных выражениях:

{n} — точно n вхождений предшествующего символа, т. е. символ внутри {} должен повторяться nраз. 
Например, почтовый индекс (для России) состоит из 6 цифр. Напишем регулярное выражение, которое будет это проверять:

let regexp = /[0-9]{6}/;
regexp.test('987985'); // true, т. к. 6 цифр подряд

[0-9] можно заменить на \d — соответствие любому цифровому символу.

let regexp = /\d{6}/;
regexp.test('987985'); // true, т. к. 6 цифр подряд

Флаги
Регулярные выражения могут иметь флаги, которые влияют на поиск.
В JavaScript их всего шесть:

i — с этим флагом поиск не зависит от регистра: нет разницы между A и a.
g — с этим флагом поиск ищет все совпадения, без него — только первое.
m — многострочный режим. Он влияет только на поведение ^ и $. 
В многострочном режиме они означают не только начало/конец текста, но и начало/конец каждой строки в тексте.
s — включает режим dotall, при котором точка. может соответствовать символу перевода строки \n. 
u — включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар.
y — режим поиска на конкретной позиции в тексте.


//1
let str = 'js';
console.log(str.toUpperCase()); //JS

//2
Создайте функцию, которая в качестве параметров принимает массив строк и строку. 
Возвращать данная функция должна новый массив, содержащий только те элементы 
переданного массива, которые начинаются с переданной строки. 
Регистр символов не должен влиять.

const fruits = ['apple', 'pineapple', 'pear', 'strawberry', 'blueberry'];
const search = 'apple';
fruits.forEach((fruits) => {
    if (fruits.toLocaleLowerCase ().includes(search.toLowerCase ())) {
        console.log(fruits);
    }
}
) // apple pineapple

//3
//Округлите число 32.58884:
//До меньшего целого
const num = 32.58884;
const result = Math.floor(num);
console.log(result); //32

//До большего целого
const num2 = 32.58884;
const result2 = Math.ceil(num2);
console.log(result2); //33

//До ближайшего целого
const num3 = 32.58884;
const result3 = Math.round(num3);
console.log(result3); //32

//4
/*Даны числа 52, 53, 49, 77, 21, 32. 
Необходимо найти среди этих чисел наименьшее и наибольшее числа и вывести их в консоль.*/

const numbers = [52, 53, 49, 77, 21, 32];
const max = Math.max(...numbers);
const min = Math.min(...numbers);

console.log(`Наибольшее число: ${max}`);
console.log(`Наименьшее число: ${min}`);


//5


