//1
Создайте функцию, которая принимает строку и один символ и 
возвращает целое число, соответствующее количеству вхождений 
второго аргумента в первом.

Если вхождений не найдено, должно быть возвращено число 0.
Примечания
Первый аргумент может быть пустой строкой
В языках без отдельного символьного типа данных 
вторым аргументом будет строка длины 1.


let filteredArr = arr.filter(function(s) {
      return s === letter;
    });
В этой строке мы используем метод filter массива arr, 
чтобы создать новый массив filteredArr, содержащий только символы, 
равные заданному символу letter. 
Метод filter принимает функцию обратного вызова 
(callback function) в качестве аргумента, 
которая будет выполнена для каждого элемента массива arr. 
Эта функция должна возвращать true для элементов, 
которые нужно включить в новый массив filteredArr, 
и false для элементов, которые нужно исключить.

Функция обратного вызова, которую мы передаем в метод filter, 
использует оператор сравнения === для сравнения каждого символа s 
в массиве arr с заданным символом single. 
Если символы равны, функция возвращает true, что указывает на то, 
что символ должен быть включен в новый массив filteredArr. 
Если символы не равны, функция возвращает false, что указывает на то, 
что символ должен быть исключен из нового массива.

Таким образом, let filteredArr = arr.filter(function(s) 
{ return s === letter; }); 
создает новый массив filteredArr, 
содержащий только те символы из исходной строки, 
которые равны заданному символу letter.

//2
Завершите функцию квадратной суммы, чтобы она возводила в квадрат 
каждое переданное ей число, а затем суммировала результаты.
Например, для [1, 2, 2] он должен вернуть 9

function squareSum(numbers) {
  return numbers.map(function(x) {
    return x * x;
  }).reduce(function(sum, current) {
    return sum + current;
  }, 0);
}

console.log(squareSum([3, 2, 2]));

вызываем метод map на массиве numbers, 
он возвращает новый массив, в котором каждый элемент старого массива 
был возведен в квадрат. 
Далее, мы вызываем метод reduce на этом новом массиве, 
который складывает все элементы нового массива и возвращает их сумму.
Точка перед reduce указывает на объект (в данном случае, на массив), 
на котором вызывается метод reduce. 
Таким образом, после метода map у нас есть новый массив, 
на котором мы вызываем метод reduce, чтобы посчитать сумму всех элементов.

//3
Найти ближайшее квадратное число, nearest_sq(n) или nearest Sq(n), 
из целого положительного числа n.

Например, если n = 111, то ближайший\_sq(n) (ближайший Sq(n)) равен 121, 
поскольку 111 ближе к 121, квадрату 11, чем 100, квадрату 10.

Если the n уже является идеальным квадратом 
(например, n = 144, n = 81 и т.д.), вам нужно просто вернуть n.

Math.sqrt(x)
Возвращает положительный квадратный корень числа.
Math.floor(x)
Возвращает значение числа, округлённое к меньшему целому.
Math.ceil(x)
Возвращает значение числа, округлённое к большему целому.
вар 1
function nearestSq(n){
    minSq = Math.floor(Math. sqrt(n)); 
    maxSq = Math.ceil(Math. sqrt(n));
      
    if ((maxSq ** 2 - n) > (n - minSq ** 2)) {
      return minSq ** 2;
    } else if ((maxSq ** 2 - n) < (n - minSq ** 2)) {
      return maxSq ** 2;
    } else {
      return n; 
      }
    }
    console.log(nearestSq(345));

    вар 2
    function nearestSq(n) {
    const minSq = Math.floor(Math.sqrt(n)); 
    const maxSq = Math.ceil(Math.sqrt(n)); 
      
    if ((maxSq ** 2 - n) >= (n - minSq ** 2)) { 
        return minSq ** 2; 
      
    } else { 
      return maxSq ** 2; 
    }
  }
  console.log(nearestSq(111));
__________________________________________
Math.round(x)
Возвращает значение числа, округлённое до ближайшего целого.

function nearestSq(n){
    let a = Math.round(Math.sqrt(n));
    return a*a;
}
  console.log(nearestSq(111));
___________________________________________
const nearestSq = n => (Math.round(Math.sqrt(n)))**2
  console.log(nearestSq(111));

//4
Завершите решение так, чтобы оно перевернуло переданную в него строку.
'world'  =>  'dlrow'
'word'   =>  'drow'

function solution(str){
  str = str.split ('');
  str = str.reverse ();
  str = str.join ('');
  return (str);
}
console.log(solution('world'));
console.log(solution('word'));
_________________________________________________
function solution(str){
    return str.split('').reverse().join('');  
  }
  console.log(solution('world'));

//5
Что, если нам нужно добавить длину слов, разделенных пробелом, 
в конце этого же слова и вернуть его в виде массива?
Example(Input --> Output)
""apple barn" --> ["apple 5", "ban 3"]
"you will win" -->["you 3", "will 4", "win 3"]
Ваша задача - написать функцию, которая принимает строку и возвращает массив 
/ список с длиной каждого слова, добавленного к каждому элементу.

Примечание: Строка будет содержать по крайней мере один элемент; 
слова всегда будут разделяться пробелом.

function addLength(str) {
        return str.split(' ').map(word => `${word} ${word.length}`); 
}
    console.log(addLength('hello world')); //[ 'hello 5', 'world 5' ]


//6
Есть предложение "3 на 2" (или "2 + 1", если хотите) на манго. 
Для заданного количества и цены (за манго) рассчитайте общую стоимость манго. 
mango(2, 3) ==> 6    # 2 mangoes for $3 per unit = $6; no mango for free 
mango(9, 5) ==> 30   # 6 mangoes for $5 per unit = $30; +3 mangoes for free

function mango(quantity, price){
    if (quantity > 0) {
        return (quantity * price) - Math.floor (quantity / 3) * price;
    } else {
        return 0;      
    }
}
console.log(mango (3,3));
/* Math.floor(quantity / 3) вычисляет количество бесплатных манго, 
которые можно получить при покупке тройки манго. 
Так как каждая тройка манго дает одно бесплатное, то можно вычислить это количество 
как целую часть от деления quantity на 3.
Вычитание Math.floor(quantity / 3) * price вычитает из общей стоимости манго стоимость бесплатных манго, 
которые мы получаем при покупке троек.*/

//вар 2
function mango(quantity, price){
    return price * (quantity - Math.floor(quantity / 3));
  }
  console.log (mango (3, 3));

//7
Натан любит кататься на велосипеде.
Поскольку Натан знает, как важно поддерживать уровень гидратации, 
он выпивает 0,5 литра воды за час езды на велосипеде.

Вам дается время в часах, и вам нужно вернуть количество литров, 
которые выпьет Натан, округленное до наименьшего значения.
For example:

time = 3 ----> litres = 1
time = 6.7---> litres = 3
time = 11.8--> litres = 5

function litres(time) {
  if (time > 0) {
    return Math.floor(time * 0.5);
  } else {
    return 0;
  }
}
console.log(litres(6.7));


//8
Учитывая набор чисел, верните аддитивное значение, обратное каждому из них. 
Каждый позитив становится негативом, а негативы становятся позитивами.

invert([1,2,3,4,5]) == [-1,-2,-3,-4,-5]
invert([1,-2,3,-4,5]) == [-1,2,-3,4,-5]
invert([]) == []

function invert(array) {
    if (array.length > 0) {
      return array.map(item => (item * -1));
    } else {
      return [];
    }
  }
  
  console.log(invert([5, 6, 8])); // [ -5, -6, -8 ]
  console.log(invert([-5, -6, -8])); // [5, 6, 8]

  //9
