//1
Создайте функцию, которая принимает строку и один символ и 
возвращает целое число, соответствующее количеству вхождений 
второго аргумента в первом.

Если вхождений не найдено, должно быть возвращено число 0.
Примечания
Первый аргумент может быть пустой строкой
В языках без отдельного символьного типа данных 
вторым аргументом будет строка длины 1.


let filteredArr = arr.filter(function(s) {
      return s === letter;
    });
В этой строке мы используем метод filter массива arr, 
чтобы создать новый массив filteredArr, содержащий только символы, 
равные заданному символу letter. 
Метод filter принимает функцию обратного вызова 
(callback function) в качестве аргумента, 
которая будет выполнена для каждого элемента массива arr. 
Эта функция должна возвращать true для элементов, 
которые нужно включить в новый массив filteredArr, 
и false для элементов, которые нужно исключить.

Функция обратного вызова, которую мы передаем в метод filter, 
использует оператор сравнения === для сравнения каждого символа s 
в массиве arr с заданным символом single. 
Если символы равны, функция возвращает true, что указывает на то, 
что символ должен быть включен в новый массив filteredArr. 
Если символы не равны, функция возвращает false, что указывает на то, 
что символ должен быть исключен из нового массива.

Таким образом, let filteredArr = arr.filter(function(s) 
{ return s === letter; }); 
создает новый массив filteredArr, 
содержащий только те символы из исходной строки, 
которые равны заданному символу letter.

//2
Завершите функцию квадратной суммы, чтобы она возводила в квадрат 
каждое переданное ей число, а затем суммировала результаты.
Например, для [1, 2, 2] он должен вернуть 9

function squareSum(numbers) {
  return numbers.map(function(x) {
    return x * x;
  }).reduce(function(sum, current) {
    return sum + current;
  }, 0);
}

console.log(squareSum([3, 2, 2]));

вызываем метод map на массиве numbers, 
он возвращает новый массив, в котором каждый элемент старого массива 
был возведен в квадрат. 
Далее, мы вызываем метод reduce на этом новом массиве, 
который складывает все элементы нового массива и возвращает их сумму.
Точка перед reduce указывает на объект (в данном случае, на массив), 
на котором вызывается метод reduce. 
Таким образом, после метода map у нас есть новый массив, 
на котором мы вызываем метод reduce, чтобы посчитать сумму всех элементов.

//3