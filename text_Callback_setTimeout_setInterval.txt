
Callback-функции в JavaScript могут быть разных видов, 
в зависимости от того, какой функционал им нужен:

Простые callback-функции: 
это функции, которые передаются в качестве аргументов другим функциям и 
вызываются внутри них. Они не имеют своего контекста и 
обычно используются для передачи данных или выполнения 
каких-то действий после выполнения асинхронной операции.

Асинхронные callback-функции: 
это функции, которые выполняются после завершения асинхронных операций, 
таких как чтение данных из файловой системы или запросы к серверу. 
Они обычно принимают два аргумента: ошибку (если она есть) 
и данные, полученные в результате операции.

Named callback-функции: 
это функции, которые определены в коде и передаются 
в другие функции. Они могут использоваться для повторного 
использования кода или улучшения читаемости.

Inline callback-функции: 
это функции, которые определяются внутри других функций 
и используются только в этом контексте. 
Они часто используются для выполнения одноразовых операций, 
таких как сортировка массивов или фильтрация элементов.

Promise-функции: 
это функции, которые возвращают объект Promise 
и обрабатывают результаты асинхронных операций. 
Они могут использоваться для упрощения асинхронного кода и обработки ошибок.

Асинхронные операции - это операции, которые выполняются в фоновом режиме, 
не блокируя выполнение остального кода. 
Примеры асинхронных операций в JavaScript:

Запросы на сервер с помощью AJAX. 
Это позволяет получать данные с сервера без перезагрузки страницы.

Отложенный вызов функции с помощью setTimeout. 
Это позволяет выполнить код через определенное время, 
не блокируя выполнение остального кода.

Работа с файлами. 
Чтение и запись файлов может занять много времени, 
поэтому эти операции выполняются асинхронно.

События пользовательского интерфейса, 
такие как клики, наведения и скроллинг. 
Они обрабатываются асинхронно, чтобы не блокировать выполнение другого кода на странице.

Работа с базами данных. 
Запросы к базам данных могут занять много времени, 
поэтому они выполняются асинхронно.

Анимации. 
Анимации также обрабатываются асинхронно, 
чтобы не блокировать выполнение другого кода.



//1
Написать функцию, которая на вход принимает массив чисел и 
callback-функцию.
Функция должна возвращать целое число, в зависимости от callback 
это может быть сумма всех чисел массива, произведение. 
Функции, вычисляющие произведение и сумму чисел массива, 
также необходимо реализовать.

function mult(arr)  {
    result = arr[0] * arr[1] * arr[2] * arr[3];
    console.log(result);
}   

function sum(arr) {
    result = arr[0] + arr[1] + arr[2] + arr[3];
    console.log(result);
}

function getResult (callback, arr) {

    callback(arr);
}

arr = [6, 9, 3, 2];
getResult (mult, arr);
getResult (sum, arr);


В данной функции getResult(), callback является аргументом, 
который представляет собой функцию, которую нужно вызвать с переданным 
ей массивом arr. Затем мы вызываем переданную функцию, 
передавая ей массив arr в качестве аргумента, используя 
синтаксис callback(arr).

Таким образом, функция getResult() не знает, какую именно функцию 
будет передана ей в качестве аргумента callback, она просто вызывает 
ее и передает массив arr. Это позволяет использовать 
функцию getResult() для вызова разных функций, передавая их в качестве 
аргументов, в зависимости от того, что хотим сделать с массивом.

//2
/*Дан массив объектов:
const users = [
	{name: 'Jon', age: 22},
	{name: 'Richard', age: 18},
	{name: 'Anton', age: 32},
	{name: 'Lida', age: 23},
	{name: 'Bob', age: 44}
];
Необходимо отсортировать элементы массива в порядке увеличения возраста.*/

function sort(arr) {
for (let i = 0; i < arr.length; i++) {
        // запускаем второй цикл, в котором будем сравнивать arr[i] с другими элементами
    for (let j = i; j < arr.length; j++) {
        // если arr[i] окажется больше какого-то из элементов,
        // то меняем их местами, для этого вводим вспомогательную
        // переменную temp
if (arr[i].toString() > arr[j].toString()) { // приводим элементы к строке, так делает оригинальный метод sort
            let temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
}
return arr;
}
function compareNum(a, b) { // сравниваем числа
	return a - b;
}
// сравниваем объекты со свойствами name и age
function compareUser(a, b) { 
	if (a.age > b.age) return 1;
	if (a.age < b.age) return -1;
	return 0;
}
function sort(arr, compareFunction) {
    for (let i = 0; i < arr.length; i++) {
	  for (let j = i; j < arr.length; j++) {
			// ввели переменную condition, которая проверяет,
			// передана ли callback-функция, и тогда сохраняет результат ее вызова
			// если не передана, то выполняет условие по умолчанию
	    const condition = compareFunction // если этот параметр не будет передан, то здесь будет undefined, т. е. ложь (false)
                ? compareFunction(arr[i], arr[j]) > 0 // в callback-функцию мы можем передать сколько угодно параметров, но они должны находиться в пределах функции
                : arr[i].toString() > arr[j].toString(); // условие по умолчанию
	    if (condition) {
				let temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
const listUsers = [
	{name: 'Jon', age: 22},
	{name: 'Richard', age: 18},
	{name: 'Anton', age: 32},
	{name: 'Lida', age: 23},
	{name: 'Bob', age: 44}
];
listUsers.sort(compareUser);// передаем в качестве параметра наш callback, но уже для User
console.log(listUsers);


//3
Создайте функцию each, которая может производить любые манипуляции 
над переданным массивом в зависимости от переданной 
callback-функции. Реализуйте несколько callback-функций, 
которые будут делать следующее:

(1) Переворачивать массив:
const arr = [1, '4', 9, 'two'];
each(arr, reversArr); // ['two', 9, '4', 1]


each() - это пользовательская функция в JavaScript, 
которая используется для итерации по элементам массива и 
выполнения операций с каждым элементом в соответствии с переданной callback-функцией.

Она принимает два аргумента: 
массив и функцию обратного вызова (callback). 
Функция обратного вызова выполняется на каждом элементе массива 
и может выполнять любые операции, в том числе изменение элементов массива.

Функция reversArr является одной из возможных callback-функций, 
которую можно передать в качестве аргумента в функцию each.

Функция reversArr должна перевернуть порядок элементов в массиве. 
Для этого можно воспользоваться методом reverse().

*****
(2) Преобразовывать все элементы к числу; если элемент 
получился NaN, то удалять его:
const arr = [1, '4', false, 9, 'two'];
each(arr, toNumberArr); // [1, 4, 0, 9]

splice() - это метод массивов в JavaScript, который позволяет изменять содержимое массива, 
удаляя или заменяя существующие элементы и/или добавляя новые элементы в массив. 
Он принимает три параметра:

Индекс, с которого нужно начинать изменять массив.
Количество элементов, которые нужно удалить, начиная с указанного индекса.
Один или несколько элементов, которые нужно добавить в массив, начиная с указанного индекса.

Например, если есть массив arr и нужно удалить первый элемент, 
то нужно использовать следующий код:

const arr = [2, 3, 4];
arr.splice(0, 1);
console.log(arr); // [3, 4], потому что метод splice() удаляет один элемент
из массива начиная с индекса 0.


function toNumberArr2(item) { //Объявление функции toNumberArr, которая принимает параметр item.
    const num = Number(item); //Создание переменной num и присвоение ей значения, полученного из item с помощью метода Number().
    if (isNaN(num)) { //Проверка, является ли num не числом (NaN) с помощью функции isNaN()
      return null; //Если num является NaN, то функция возвращает значение null.
    }
    return num; //Если num не является NaN, то функция возвращает его значение.
  }
  
  function each(arr2, callback) { //Объявление функции each, которая принимает два параметра: arr (массив) и callback (функция обратного вызова).
    for (let i = arr2.length - 1; i >= 0; i--) { //Создание цикла for со счетчиком i, который проходит по массиву arr в обратном порядке.
      const item = callback(arr2[i]); //Вызов функции callback для элемента arr[i] и присвоение ее результата переменной item.
      if (item === null) { //Если значение item равно null, то удаляем элемент i массива с помощью метода splice().
        arr2.splice(i, 1);
      } else { //Если значение item не равно null, то присваиваем его элементу i массива arr.
        arr2[i] = item;
      }
    }
  }

//4
/*Напишите программу, которая на протяжении 30 секунд, 
каждые 3 секунды, будет выводить в консоль текущую дату. 
Последней строкой должно выводиться сообщение «30 секунд прошло».*/
_________________________________________________________________________________________________________
.toLocaleString() является методом объекта Date в JavaScript, 
который возвращает строковое представление даты и времени 
в соответствии с локальными настройками языка и региональных параметров 
операционной системы, на которой выполняется скрипт.

Метод .toLocaleString() используется для преобразования даты в строковое представление 
в зависимости от текущего языкового стандарта и региональных настроек.
Например, чтобы получить текущую дату и время в формате "день.месяц.год, часы:минуты:секунды" 
на русском языке, можно использовать следующий код:

const currentDate = new Date();
const options = {
  day: 'numeric',
  month: 'numeric',
  year: 'numeric',
  hour: 'numeric',
  minute: 'numeric',
  second: 'numeric'
};
const formattedDate = currentDate.toLocaleString('ru-RU', options);
console.log(formattedDate);
__________________________________________________________________________________________________________


let counter = 0; //Создание переменной counter и присвоение ей значения 0. 
//Она будет использоваться для отслеживания времени внутри функции printTime.

function printTime() {  
  console.log(new Date().toLocaleString());
  counter += 3;

 Определение функции printTime(), которая будет вызываться каждые 3 секунды 
 и выводить текущую дату и время в консоль. 
 Затем она увеличивает значение counter на 3. 
 Далее, если counter больше или равно 30, 
 функция выводит сообщение "30 секунд прошло" и 
 останавливает интервал выполнения функции с помощью clearInterval().

if (counter >= 30) {
    console.log("30 секунд прошло");
    clearInterval(intervalId);
  }
}

const intervalId = setInterval(printTime, 3000);


//5
/*У нас есть код, имитирующий телефонный звонок:

function calling() {
    console.log('Звоню!')
};

function beeps() {
    setTimeout(() => {
        console.log('Идут гудки...')
    }, 1000);
}

function talk() {
    console.log('Разговор')
}

calling();
beeps();
talk();

Сейчас, если его запустить, последовательность будет 
'Звоню!', 'Разговор', 'Идут гудки…', но разговор всегда начинается после гудков, 
поэтому вам нужно исправить данный код так, 
чтобы выводилась верная последовательность:
'Звоню!','Идут гудки…','Разговор'
Добавлять новые setTimout и setInterval нельзя, 
также нельзя удалять существующий setTimout, 
но можно менять код внутри его.
____________________________________________________________________________________
/* передать функцию talk() в качестве callback-функции в функцию beeps() 
внутри таймера setTimeout, чтобы она вызывалась после завершения таймера. 
Также, чтобы был правильный порядок выполнения функций, 
вызвать функцию beeps() внутри функции calling() после вывода сообщения "Звоню!". */

function calling() {
    console.log('Звоню!');
    beeps(talk);
};

function beeps(callback) {
    setTimeout(() => {
        console.log('Идут гудки...');
        callback();
    }, 1000);
}

function talk() {
    console.log('Разговор');
}

calling();
/*после вывода сообщения "Звоню!", функция calling() вызывает функцию beeps() 
с передачей в нее функции talk() в качестве аргумента. 
Функция beeps() запускает таймер setTimeout() 
и вызывает переданную в нее callback-функцию, 
т.е. функцию talk(), после того, как таймер завершится.*/
__________________________________________________________________________________________